# Custom Jwt Token
- The client shared their Azure AD B2C directory. A token is generated by configuring an app and a user flow in the Azure Portal. When a user logs in via the flow, Azure AD B2C returns a token to the app after successful authentication.
- During the project, I faced a challenge with **Azure AD B2C tokens**. By default, B2C issues a standard JWT after authentication, but our internal microservices had stricter requirements:

* **Security isolation**: APIs should not directly depend on external B2C tokens.
* **Lightweight tokens**: The default B2C token contained many unnecessary claims.
* **Custom claims**: Business-specific data needed to be included.
* **Performance**: We wanted to avoid repeated calls to B2C for every service request.

To solve this, I implemented a **custom JWT token flow**:

1. **User Authentication**

   * The client shared their Azure AD B2C directory.
   * I configured an application and user flow in the Azure Portal.
   * After login, B2C returned its standard token.

2. **Custom Token Issuance**

   * Once the B2C token was validated, I issued a **lightweight custom JWT** signed with our own keys.
   * This token contained only the claims required by internal APIs and supported our custom business logic.

3. **Azure AD B2C Custom Policies**

   * I used the **Identity Experience Framework** (XML-based custom policies).
   * Configured policy keys (RSA signing/encryption keys).
   * Uploaded TrustFrameworkExtensions.xml and supporting policy files.
   * Integrated the external app registration (`thrd_prod_ExternalApi-JwtIssuer`) for token validation.

4. **Key and Certificate Management**

   * Generated RSA key pairs locally (`prod_private.pem`, `prod_public.pem`).
   * Uploaded the public certificate into B2C for signing.
   * Referenced it in custom policies for secure token generation.

5. **Automation and Validation**

   * Wrote Python scripts (`custom_jwt.py`, `old_new_token.py`) to generate and refresh tokens.
   * Extracted modulus and exponent from RSA public keys and configured them in policies.
   * Tested the flow with `curl` against API endpoints in the production environment.

**Outcome**:

* Internal microservices now trust only the custom JWT.
* Tokens are smaller, easier to process, and contain only necessary claims.
* We achieved a clean separation: B2C for authentication, custom JWT for internal authorization and service-to-service communication.
* This improved both **security posture** and **system performance**.

---
### resume highlight
Implemented a **custom JWT token solution** in Azure AD B2C to improve security and performance. Designed custom policies, managed RSA key pairs, and automated token generation, enabling internal microservices to use lightweight tokens with only required claims and custom business logic, reducing dependency on external B2C tokens.
### one line
Developed custom JWT token flow in Azure AD B2C to enable lightweight, secure, and business-specific tokens for internal microservices.
