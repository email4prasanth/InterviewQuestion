# Custom JWT Token Flow in Azure AD B2C

## 1. Context and Challenge

The client provided their **Azure AD B2C directory**, which by default issues large JWT tokens with many claims after authentication. However, our internal microservices required stricter security and efficiency:

* **Security isolation**: Internal APIs should not directly rely on external B2C tokens.
* **Lightweight tokens**: The default token contained unnecessary claims.
* **Custom claims**: Business-specific data needed inclusion.
* **Performance**: Avoid repeated B2C validation calls for every request.

---

## 2. Technical Complexity

The task required designing a custom JWT token issuance flow that integrated seamlessly with Azure AD B2C:

* **Azure AD B2C setup**: Application registration, user flows, and token validation.
* **Custom Policies (Identity Experience Framework)**: XML-based configuration of token issuance, signing keys, and trusted app registrations.
* **RSA Key Management**:

  * Generated private/public key pairs locally.
  * Uploaded public certificates to B2C for token signing.
  * Configured modulus and exponent in policies.
* **Automation**: Python scripts (`custom_jwt.py`, `old_new_token.py`) for token generation, refresh, and validation.
* **Testing**: Used `curl` against production API endpoints to validate tokens end-to-end.

---

## 3. Client and Team Requirements

* Maintain **B2C for authentication** while issuing **internal custom tokens** for authorization.
* Ensure **secure key management** with RSA keys and certificates.
* Provide **customizable, lightweight tokens** containing only essential and business-specific claims.
* Deliver an approach that improved **system performance** and **security posture**.

---

## 4. Solution Approach

* Configured **B2C user flows** for initial authentication.
* Implemented **custom JWT issuance layer**:

  * Validated B2C token.
  * Issued internal JWT signed with private key.
  * Injected only necessary and business claims.
* Designed **custom policies** (TrustFrameworkExtensions.xml) referencing uploaded RSA certificates.
* Integrated app registration (`thrd_prod_ExternalApi-JwtIssuer`) for trust configuration.
* Automated token lifecycle with Python utilities for generation, refresh, and verification.

---

## 5. Outcome / Result

* Internal microservices now **trust only custom JWT tokens**.
* Tokens are **smaller, faster to process, and business-specific**.
* Achieved **clean separation**: B2C handles authentication, custom JWT handles authorization and service-to-service communication.
* Improved **system performance** and strengthened **security isolation**.

---

## Concise, Resume-Friendly Markdown Version

### DevOps Engineer | Project: Custom JWT Token Flow in Azure AD B2C

* Designed and implemented a **custom JWT issuance flow** on top of Azure AD B2C to enforce security isolation and improve performance.
* Built **custom policies (Identity Experience Framework)** with RSA key pairs and certificate management for secure token generation.
* Automated **token generation and validation** using Python scripts, ensuring lightweight, business-specific claims.
* Enabled internal microservices to **trust only custom tokens**, reducing dependency on external B2C tokens.
* Delivered improved **security posture and system efficiency** through clean separation of authentication and authorization.

## Resume One Line

* Implemented a custom JWT flow in Azure AD B2C, enabling lightweight, secure, business-specific tokens for internal microservices and improving system performance.

## 30 seconds version
In one project, I implemented a **custom JWT token flow on top of Azure AD B2C**. Instead of letting our microservices rely directly on the large default B2C tokens, I built a layer that validated the B2C token and then issued a **lightweight, business-specific JWT** signed with our own keys. I used **custom policies and RSA certificates** in B2C, along with Python scripts for automation. This gave us smaller tokens, improved performance, and stronger security isolation by cleanly separating authentication from internal authorization.
